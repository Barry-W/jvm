第七章 虚拟机类加载机制

概述：
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。


类加载时机
类加载从内存开始到结束，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。
其中，加载、验证、准备、初始化、和卸载这五个阶段的顺序是确定的。

其中，虚拟机初始化限定条件为：
1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行初始化，则需要先触发其初始化。
2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其父类的初始化。
3.当初始化一个类的时候，如果发现其父类还没有初始化，需要先触发其父类初始化。
4.当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会先初始化这个类。

加载：
加载阶段是“类加载”过程的一个阶段，在此阶段虚拟机需完成：
a.通过一个类的全限定名来获取定义此类的二进制字节流。
b.将这个字节流所代表的静态存储结构转化为方法区运行时数据结构。
c.在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

加载阶段（加载中获取二进制字节流的动作），是开发期可控性最强的阶段。

验证：
1.验证文件格式；
2.元数据验证；
3.字节码验证；
4.符号引用验证；

准备：
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区进行分配。

通常情况下，静态数据类型的值为初始值（如int为0),但但又final修饰时，则表示ConstantValue属性，在编译时Javac将会为value生成ConstantValue属性，在准备
阶段虚拟机就会根据ConstantValue的设置将value赋值为123

解析：
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义定位到即可。符号引用与虚拟机的实现内存布局无关，引用的目标不一定已经
加载到内存中。
直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。

类或接口的解析：
分三步：
    a.如果为非数组类型，则把对应全限定名传递给所处类来加载被引用的地方。
    b.如果为数组类型，如果数组元素为对象，则同第一步加载
    c.如之前步骤未有异常，则还需要进行符号引用验证，确认是否有权限。

字段解析：
  对未被解析过字段引用，将会对字段表内class_index项中索引CONSTANT_Class_info符号进行解析，解析成功后，将对字段进行后续搜索：
  a.如果C本身包含简单名称和字段描述符都与目标相匹配的字段，则返回该字段的直接引用，结束查找
  b.否则，如果对应引用实现了接口，将会按照继承关系从上往下递归搜索各个接口及其父接口，如果接口中与之相匹配，则返回该字段直接引用
  c.否则，按照继承关系从上往下递归搜索其父类，如果与之相匹配，则返回该字段直接引用，结束查找
  d.抛出异常

类方法解析：
    类方法解析与字段解析一样，需先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，解析成功后，按后续类方法搜索：
    a.类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是接口，抛出异常
    b.上一步骤通过，查找是否有简单名称和描述符都与目标匹配的方法，有则返回方法的直接引用，结束
    c.否则，在类的父类中递归查找是否有简单名称和描述符都与目标想匹配的方法，如果有则返回这个方法的直接引用，结束
    d.否则，在类实现的接口列表及它们的父接口中递归查找是否有简单名称和描述符都与目标相匹配的方法，存在则查找结束，抛出异常
    e.抛出异常
    
    

接口方法解析：
    接口方法也需先解析接口方法表中class_index项中索引的方法所属的类或接口的符号引用，解析成功按如下步骤进行后续的接口方法搜索；
    a.与类方法解析相反，如果在接口方法中发现class_index中的索引为类，直接抛出异常
    b.否则，在接口中查找是否有简单名称和描述都与目标相匹配的方法，如有则返回方法的直接引用，结束查找；
    c.否则，在接口的父接口中递归查找，直道java.lang.Object类为止，查看是否有简单名称和描述符都与目标相匹配的方法，如有则返回方法的直接引用，结束；
    d.否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常

初始化：
    类初始化为类加载阶段的最后一步，在此过程中，除了加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制，初始化时，
    开始真正执行类中定义的java程序代码。
    在准备阶段，变量已经赋值一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化变量和其他资源。
    <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语块中的语句合并产生的。
    <clinit>（）与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<client>（）方法执行之前，父类的<client>（）方法已经执行完毕，
    因此虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object
    
    由于父类<clinit>（）方法优先执行，表示父类中定义的静态语句块要优先于子类的变量赋值操作。











