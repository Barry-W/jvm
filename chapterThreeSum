
第三章  垃圾收集器与内存分配策略

   3.1 概述
     GC回收原因：
       1.哪些内存需要回收；
       
       2.什么时候回收；
       
       3.如何回收；
       
  3.2 确定回收对象范围
    3.2.1 应用计数法：
       给对象中添加一个引用计数器，每当被引用计数器加1，失效计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。
       
       特点：实现简单、效率较高；难以解决相互循环引用问题。
       
    3.2.2 根搜索算法
       通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何
    引用链相连，则证明此对象是不可用的。
       java中，可作为GC Roots的对象包括以下：
         1.虚拟机栈（栈帧中的本地变量表）中的引用的对象。
         2.方法区中的类静态属性引用的对象。
         3.方法区中的常量引用的对象。
         4.本地方法栈中JNI（即一般说的Native方法）的引用的对象。
         
     3.2.3 引用分类
       JDK1.2之后，引用概念扩充，分为强引用、软引用、弱引用、虚引用四种。引用强度依次逐渐减弱。
        强引用：在程序代码中普遍存在，类似 Object obj = new Object(); 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
        软引用：有用但并非必须的对象。在系统将要发生内存泄漏异常之前，会将这些对象列进回收范围之中并进行第二次回收。
        弱引用：非必需对象，强度比软引用更弱。弱引用只能生存到下一次垃圾收集发生之前。
        虚引用：最弱引用关系。为一个对象设置虚引用关联的目的即希望该对象被收集器回收时收到一个系统通知。
         
     3.2.4 回收阶段
       根搜索算法中不可达的对象，并非都要被回收，暂时处于“缓刑”阶段，真正宣告对象死亡，至少要有两次标记过程：第一次标记在GC Roots相连接的时候做标记，
       第二次在第一次标记之后做筛选，判断该对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或该方法已经被调用，则不执行finalize方法，
       即进行回收。
       
       
     3.2.5 回收方法区
      


     3.2.6 垃圾收集算法










