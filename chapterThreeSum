
第三章  垃圾收集器与内存分配策略

   3.1 概述
     GC回收原因：
       1.哪些内存需要回收；
       
       2.什么时候回收；
       
       3.如何回收；
       
  3.2 确定回收对象范围
    3.2.1 应用计数法：
       给对象中添加一个引用计数器，每当被引用计数器加1，失效计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。
       
       特点：实现简单、效率较高；难以解决相互循环引用问题。
       
    3.2.2 根搜索算法
       通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何
    引用链相连，则证明此对象是不可用的。
       java中，可作为GC Roots的对象包括以下：
         1.虚拟机栈（栈帧中的本地变量表）中的引用的对象。
         2.方法区中的类静态属性引用的对象。
         3.方法区中的常量引用的对象。
         4.本地方法栈中JNI（即一般说的Native方法）的引用的对象。
         
     3.2.3 引用分类
       JDK1.2之后，引用概念扩充，分为强引用、软引用、弱引用、虚引用四种。引用强度依次逐渐减弱。
        强引用：在程序代码中普遍存在，类似 Object obj = new Object(); 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
        软引用：有用但并非必须的对象。在系统将要发生内存泄漏异常之前，会将这些对象列进回收范围之中并进行第二次回收。
        弱引用：非必需对象，强度比软引用更弱。弱引用只能生存到下一次垃圾收集发生之前。
        虚引用：最弱引用关系。为一个对象设置虚引用关联的目的即希望该对象被收集器回收时收到一个系统通知。
         
     3.2.4 回收阶段
       根搜索算法中不可达的对象，并非都要被回收，暂时处于“缓刑”阶段，真正宣告对象死亡，至少要有两次标记过程：第一次标记在GC Roots相连接的时候做标记，
       第二次在第一次标记之后做筛选，判断该对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或该方法已经被调用，则不执行finalize方法，
       即进行回收。
       
       
     3.2.5 回收方法区
       方法区（永久代）垃圾收集主要回收两部分：废弃常量和无用的类。
       1. 回收废弃常量：类似java堆中对象。如常量池中常量，内存回收时需满足：没有任何String对象引用常量池中常量；其他地方也没引用该字面量。此时内存回收，
       该常量会被系统请出常量池。（常量池中的其他类或接口中的方法、字段的符号引用类似）
       
       2. 回收废弃类：满足三个条件：a.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。b.加载类的classloader已经被回收
       c.该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
       注：满足上述三个条件，虚拟机可以对满足上述的类进行回收。仅仅是可以，和对象回收不同（不使用了就必然回收）。是否对类进行回收，HotSpot虚拟机提供
       了-Xnoclassgc参数进行控制，还可以使用-verbose：class及-XX：+TraceClassLoading、-XX：+TraceClassUnloading查看类的加载和卸载信息。
       -verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用但是-XX：+TraceClassLoading参数需要fastdebug版的虚拟机支持。
       
       
     3.3 垃圾收集算法
         1.标记-清楚算法
           标记：标记所有需要回收的对象；
           清楚：在标记完成后统一回收掉所有被标记的对象。
           
           缺点：效率问题，标记和清楚过程的效率不高；空间问题，标记清楚之后会产生大量不连续的内存碎片。（空间碎片太多可能会导致，当程序在以后的运行
           过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作）
         
         2.复制算法
           原因：为了解决效率问题，复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块。
           算法原理：当一块内存用完，将存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
           特点：不用考虑碎片等复杂情况；实现简单，运行高效。但内存缩小为原来一半。
           
           现在商业虚拟机都采用该算法回收新生代。由于大多数对象朝生夕死，不需要按照1：1划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的
           Survivor空间。回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。
           HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用的内存空间为整个新生代容量的90%，只有10%的内存是会被浪费掉的。
         
         3.标记整理算法
           老年代算法。
           标记过程仍然与“标记-清除算法”一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内
           存。
           
         
         4.分代收集算法
           当前商业虚拟机的垃圾收集都采用“分代收集算法”。根据对象存活周期不同，将内存分为几块，一般分为新生代和老年代。新生代中，每次垃圾收集时都发现
           有大批对象死去，只有少量存货，那就选用复制算法。而老年代中因对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清除或标记-整理算法
           来进行回收
           
         
      3.4 垃圾收集器
      
        新生代：Serial，ParNew，Parallel Scavenge, G1
        
        老年代：CMS， Serial Old(MSC), Parallel Old, G1
      
         1. Serial 收集器
           特点：单线程，进行垃圾收集时，暂停其他所有的工作线程（Stop The World）
         2. ParNew 收集器
           Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数（--XX：SurvivorRatio、--XX:Preten
           ureSizeThreshold、-XX:HandlePromotionFaiure等）、收集算法、stop the world、对象分配规则、回收策略都与Serial收集器完全一样。
           除了Serial外，只有它可以与CMS收集器配合工作。
           
         3. Parallel Scavenge 收集器
           复制算法的并行多线程收集器。Parallel Scavenge收集器的目标是达到一个可控的吞吐量。（吞吐量=运行用户代码时间/运行用户代码时间+垃圾回收时间）
           高吞吐量可以有效利用CPU时间。
           Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间：-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的
           -XX:GCTimeRatio参数。
           -XX:+UseAdapiveSizePolicy参数，开启后，不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升到老年代
           对象的年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿
           时间或最大的吞吐量，称为GC的自适应调节策略（GC Ergonomics）。
           
           
         4. Serial Old 收集器
           Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器。使用“标记-整理”算法。主要在client模式下供虚拟机使用。在Server模式下，
           两大用途：在jdk1.5之前的版本中与Parallel Scanvenge收集器搭配使用；另一个是作为CMS收集器的后预案。
           
         
         5. Parallel Old 收集器
           Parallel Old是Parallel Scanvenge收集器的老年代版本，使用多线程和“标记-整理”算法。该收集器在jdk1.6之后提供。在注重吞吐量及CPU资源敏感
           的场合，可优先考虑Parallel Scavenge加Parallel Old收集器。
         
         6. CMS 收集器
           CMS收集器是一种以获取最短回收停顿时间为目标的收集器。在互联网或B/S系统的服务端上，系统重视响应速度，提升体验。CMS符合这类应用需求。
           CMS收集器是基于“标记-清除”算法实现的。运作过程为：
           1）初始标记
           2）并发标记
           3) 重新标记
           4) 并发清除
           
           初始标记和重新标记仍然需要“Stop The World”.初始标记为了标记一下GC Roots能直接关联到的对象，速度很快；并发标记就是进行GC Roots Tracing的
           过程，重新标记是为了修正并发标记期间，因用户程序继续操作导致标记产生变动的对象记录。该阶段停顿时间比初始标记时间稍长，远比并发标记时间短。
           由于整个过程中耗时最长的并发标记和并发清除中，收集器线程都可以与用户线程一起工作，总体上，CMS收集器的内存回收过程是与用户线程一起并发地执行。
           
           CMS特点：并发收集，低停顿
           
           CMS缺点：CMS收集器对CPU资源非常敏感。
                   CMS收集器无法处理浮动垃圾（Floating Garbage）。可能出现“Concurrent Mode failure”失败而导致另一次Full GC的产生。
                   CMS收集器是基于“标记-清除算法”实现的。回收结束时会产生大量空间碎片。会出现老年代还有很大空间，却无法找到足够大的连续空间来分配对象。
                      CMS为了解决该问题，提供了-XX：+UseCMSCompactAtFullCollection开关参数，用于在Full GC服务后，额外执行一个碎片整理过程，其中
                      内存整理过程无法并发。另有-XX：CMSFullGCBeforeCompaction，设置执行多少次不压缩的Full GC后，跟着带来一次压缩。
         7.G1 收集器
           G1收集器是当前收集器技术发展前沿成果。基于“标记-整理”算法实现；另外可以精准控制停顿，能够让使用者明确指定在一个长度为M毫秒的时间片段中，
           消耗在垃圾收集上的时间不超过N毫秒。G1收集器可以在实现基本不牺牲吞吐量的前提下完成低停顿的内存回收，由于它能极力避免全区域垃圾回收。
           G1将整个Java堆（包括新生代和老年代）划分为多个大小固定的独立区域，并且跟踪这些区域的垃圾堆积程度，在后台维护一个优先礼拜每次根据允许的收集
           时间，优先回收垃圾最多的区域。
         
         8.垃圾收集器参数总结
              参数                                              描述
           UseSerialGC
           UseParNewGC
           UseConcMarkSweepGC
           UseParallelGC
           UseParallelOldGC
           SurvivorRatio
           PretenureSizeThreshold
           MaxTenuringThreshold
           UseAdaptiveSizePolicy
           HandlePromotionFailure
           ParallelGCThreads
           GCTimeRatio
           MaxGCPauseMillis
           CMSinitiatingOccupancyFraction
           UseCMSCompactAtFullCollection
           CMSFullGCBeforeCompaction
           
           
           
         
         
      3.5 内存分配与回收策略
         内存管理最终归为两类：分配对象给内存、回收分配给对象的内存。
         
         对象内存分配：通常是指在堆上分配。对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。
         
         * 3.5.1 对象优先在Eden分配
            大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC
            
            新生代GC（Minor GC）：指发生在新生代的垃圾回收动作，因为Java对象大多都具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。
            
            老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对，在ParallelScavenge收集器
            的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢十倍以上。
            
         * 3.5.2 大对象直接进入老年代
            大对象对虚拟机的内存分配不友好。（更坏情况是遇到一群朝生夕死的短命大对象），经常出现大对象很容易导致内存还有不少空间时就提前触发垃圾收集
            以获取足够的连续空间来安置它们。
            虚拟机中提供了一个-XX：PertenureSizeThreshold参数，令大于这个设置的对象直接在老年代中分配。这样做的目的是避免在Eden区及两个Survivor
            区之间发生大量的内存拷贝。
         
         
         * 3.5.3 长期存活的对象将进入老年代
           虚拟机给每个对象定义一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间
           中，并将年龄设为1.对象在Survivor区中每熬过一次Minor GC，年龄就增加1，当他的年龄增加到特定（默认15），将晋升到老年代中。对象晋升老年代的
           阈值可以通过参数-XX：MaxTenuringThreshold来设置。
         
         * 3.5.4 动态对象年龄判定
         
         
         * 3.5.5空间分配担保
           
         








