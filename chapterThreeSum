
第三章  垃圾收集器与内存分配策略

   3.1 概述
     GC回收原因：
       1.哪些内存需要回收；
       
       2.什么时候回收；
       
       3.如何回收；
       
  3.2 确定回收对象范围
    3.2.1 应用计数法：
       给对象中添加一个引用计数器，每当被引用计数器加1，失效计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。
       
       特点：实现简单、效率较高；难以解决相互循环引用问题。
       
    3.2.2 根搜索算法
       通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何
    引用链相连，则证明此对象是不可用的。
       java中，可作为GC Roots的对象包括以下：
         1.虚拟机栈（栈帧中的本地变量表）中的引用的对象。
         2.方法区中的类静态属性引用的对象。
         3.方法区中的常量引用的对象。
         4.本地方法栈中JNI（即一般说的Native方法）的引用的对象。
         
     3.2.3 引用分类
       JDK1.2之后，引用概念扩充，分为强引用、软引用、弱引用、虚引用四种。引用强度依次逐渐减弱。
        强引用：在程序代码中普遍存在，类似 Object obj = new Object(); 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
        软引用：有用但并非必须的对象。在系统将要发生内存泄漏异常之前，会将这些对象列进回收范围之中并进行第二次回收。
        弱引用：非必需对象，强度比软引用更弱。弱引用只能生存到下一次垃圾收集发生之前。
        虚引用：最弱引用关系。为一个对象设置虚引用关联的目的即希望该对象被收集器回收时收到一个系统通知。
         
     3.2.4 回收阶段
       根搜索算法中不可达的对象，并非都要被回收，暂时处于“缓刑”阶段，真正宣告对象死亡，至少要有两次标记过程：第一次标记在GC Roots相连接的时候做标记，
       第二次在第一次标记之后做筛选，判断该对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或该方法已经被调用，则不执行finalize方法，
       即进行回收。
       
       
     3.2.5 回收方法区
       方法区（永久代）垃圾收集主要回收两部分：废弃常量和无用的类。
       1. 回收废弃常量：类似java堆中对象。如常量池中常量，内存回收时需满足：没有任何String对象引用常量池中常量；其他地方也没引用该字面量。此时内存回收，
       该常量会被系统请出常量池。（常量池中的其他类或接口中的方法、字段的符号引用类似）
       
       2. 回收废弃类：满足三个条件：a.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。b.加载类的classloader已经被回收
       c.该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
       注：满足上述三个条件，虚拟机可以对满足上述的类进行回收。仅仅是可以，和对象回收不同（不使用了就必然回收）。是否对类进行回收，HotSpot虚拟机提供
       了-Xnoclassgc参数进行控制，还可以使用-verbose：class及-XX：+TraceClassLoading、-XX：+TraceClassUnloading查看类的加载和卸载信息。
       -verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用但是-XX：+TraceClassLoading参数需要fastdebug版的虚拟机支持。
       
       
     3.3 垃圾收集算法
         1.标记-清楚算法
           标记：标记所有需要回收的对象；
           清楚：在标记完成后统一回收掉所有被标记的对象。
           
           缺点：效率问题，标记和清楚过程的效率不高；空间问题，标记清楚之后会产生大量不连续的内存碎片。（空间碎片太多可能会导致，当程序在以后的运行
           过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作）
         
         2.复制算法
           原因：为了解决效率问题，复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块。
           算法原理：当一块内存用完，将存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
           特点：不用考虑碎片等复杂情况；实现简单，运行高效。但内存缩小为原来一半。
           
           现在商业虚拟机都采用该算法回收新生代。由于大多数对象朝生夕死，不需要按照1：1划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的
           Survivor空间。回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。
           HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用的内存空间为整个新生代容量的90%，只有10%的内存是会被浪费掉的。
         
         3.标记整理算法
           老年代算法。
           标记过程仍然与“标记-清除算法”一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内
           存。
           
         
         4.分代收集算法
           当前商业虚拟机的垃圾收集都采用“分代收集算法”。根据对象存活周期不同，将内存分为几块，一般分为新生代和老年代。新生代中，每次垃圾收集时都发现
           有大批对象死去，只有少量存货，那就选用复制算法。而老年代中因对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清除或标记-整理算法
           来进行回收
           
         
      3.4 垃圾收集器
      
        新生代：Serial，ParNew，Parallel Scavenge, G1
        
        老年代：CMS， Serial Old(MSC), Parallel Old, G1
      
         1. Serial 收集器
           特点：单线程，进行垃圾收集时，暂停其他所有的工作线程（Stop The World）
         2. ParNew 收集器
           Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数（--XX：SurvivorRatio、--XX:Preten
           ureSizeThreshold、-XX:HandlePromotionFaiure等）、收集算法、stop the world、对象分配规则、回收策略都与Serial收集器完全一样。
           除了Serial外，只有它可以与CMS收集器配合工作。
           
         3. Parallel Scavenge 收集器
           复制算法的并行多线程收集器。Parallel Scavenge收集器的目标是达到一个可控的吞吐量。（吞吐量=运行用户代码时间/运行用户代码时间+垃圾回收时间）
           高吞吐量可以有效利用CPU时间。
           Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间：-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的
           -XX:GCTimeRatio参数。
           -XX:+UseAdapiveSizePolicy参数，开启后，不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升到老年代
           对象的年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿
           时间或最大的吞吐量，称为GC的自适应调节策略（GC Ergonomics）。
           
           
         4. Serial Old 收集器
         
         5. Parallel Old 收集器
         
         6. CMS 收集器
         
         7.G1 收集器
         
         8.垃圾收集器参数总结
         
         
      3.5 内存分配与回收策略








