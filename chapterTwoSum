2. Java内存区域与内存溢出异常



 2.1 概述
 java虚拟机长官内存管理。
    优点：不需要为每个new操作配写释放内存代码，较少出现内存泄漏和溢出情况。
    缺点：不了解虚拟机管理内存机制，排查将变得困难。
    
 2.2 运行时区域
  2.2.1 程序计数器
    程序计数器是一块内存较小空间，可以看作当前线程所执行的字节码行号指示器。特点：由于单核执行多线程特点，该内存区域线程私有。
    
 2.2.2 Java虚拟机栈
    虚拟机栈是描述方法执行的内存模型：每个方法执行的时候都会创建栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。特点：线程私
  有，生命周期与线程相同。
    局部变量表存放基本数据类型，对象引用类型（指向对象起始地址的引用指针）。长度64位long和duble占用两个局部变量空间，其余数据类型占一个。 异常：
  StackOverflowError，OutOfMemoryError。
  
 2.2.3 本地方法栈
    与虚拟机栈类似，区别为该区域为虚拟机使用到的Native方法服务。
    
 2.2.4 Java堆
    几乎所有对象实例都在此区域分配内存。Java虚拟机规范中描述的为：所有的对象实例及数组都要在堆上分配。
    Java堆细分为：新生代老年代；接着细致区分：Eden空间、From Survivor空间、To Survivor空间。
    特点：可出于物理上不连续的内存空间，只要逻辑上连续。线程共享
    
 2.2.5 方法区
    方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。
    特点：线程共享。虚拟机规范限制非常宽松。回收效率不高。
 
 2.2.6 运行时常量池
    运行时常量池是方法区的一部分。Class文件夹中的版本，字段，方法接口等信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用。
    
 2.2.7 直接内存
    直接内存，使用Native函数库直接分配堆外内存，通过存储在Java堆中的DirectByteBuffer对象作为内存的引用操作。这样以便提供性能。
 
 
 2.3 对象访问
    例:
      Object obj = new Object();
      Object obj该语义将会反映到java栈的本地变量表中，作为一个reference类型数据。
      new Object()该语义将会反映到java堆中，形成一块存储Object类型所有实例数据值。
      
    对象访问方式：
      1.句柄式：
        java堆中将会划出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。
        优点：稳定句柄地址
        
      2.直接指针访问：
        java堆中存放了对象实例数据和对象类型数据的指针。
        优点：访问速度更快
        
        
      
      2.4 实战： OutOfMemoryError异常（待续）
        
      
      
      
      
      
      
      
      
      
      
      
      




